# 这里是全局设置区域，酌情修改
global {
	perm_cache=2048;   # 缓存文件大小，单位KB
	cache_dir="/var/pdnsd";  # 缓存文件位置，保留默认
#	pid_file=/var/run/pdnsd.pid;  # pid文件，不用管
	run_as="nobody";          # runas，保留默认
	server_ip=127.0.0.1;  # 监听所有
	server_port=5300;
	status_ctl=on;     # 保留on
#	paranoid=on;       # This option reduces the chance of cache poisoning
	                   # but may make pdnsd less efficient, unfortunately.
	query_method=tcp_only;  # 只使用UDP，保留默认
	min_ttl=6h;       # 最小TTL时间，自己酌情往上加，默认是15分钟
	max_ttl=1w;        # 最长TTL时间，默认一周
	timeout=10;        # 全局超时时间，默认10秒，酌情修改
	neg_domain_pol=on; # 用到neg domain的话可以试试，不用就不用管
	udpbufsize=1024;   # 默认
}
 
# 这个是server区域，可以定义多组，定义pdnsd的上游dns
server {
	label="JapanRoot";   # 为这组server起一个名字
	ip=202.12.27.33;    # 填写DNS的IP地址，多个地址逗号分隔，可以换行，分号结尾
	port=53;       # 填写DNS的端口，我这里上一级是3.4.5.6，监听的5353
                         # 如果使用114DNS等公共 DNS 这里端口号应该是53，或者删除该行也行
#	proxy_only=on;     # Do not query any name servers beside your ISP's.
	                   # This may be necessary if you are behind some
	                   # kind of firewall and cannot receive replies
	                   # from outside name servers.
	timeout=4;         # 超时值，酌情修改
	uptest=none;       # 是否进行可用性检查，none=不检查，具体方法看官方文档
	interface=eth0;    # 可用性检查所用的interface名
	interval=10m;      # 检查频率
	purge_cache=off;   # 如果off，pdnsd不会主动清除缓存中过期的项目 除非缓存满了
	edns_query=on;     # 是否使用edns
}
